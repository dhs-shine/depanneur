#!/usr/bin/perl 
#
# SMOCK - Simpler Mock
# by Dan Berrange and Richard W.M. Jones.
# Copyright (C) 2008 Red Hat Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
BEGIN {
  my ($wd) = $0 =~ m-(.*)/- ;
  $wd ||= '.';
  unshift @INC,  "$wd/build";
  unshift @INC,  "$wd";
  unshift @INC,  "$ENV{'VIRTUAL_ENV'}/usr/lib/build"
}

use strict;
use warnings;
use threads;
use threads::shared;
use File::Find ();
use Term::ANSIColor qw(:constants);

# Global vars


# Flag to inform all threads that application is terminating
my $TERM:shared=0;

# Prevents double detach attempts
my $DETACHING:shared;

# Signal handling
$SIG{'INT'} = $SIG{'TERM'} = sub {
        print("^C captured\n");
        $TERM=1;
};

# Set the variable $File::Find::dont_use_nlink if you're using AFS,
# since AFS cheats.

# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

sub wanted;


use Cwd;
use Getopt::Long;
use Pod::Usage;
use File::Temp qw(tempfile);
use Build;
use Build::Rpm;
use Data::Dumper;
use File::Basename;

my @threads;
my @exclude = ();
my $arch = "i586";
my $path = "";
my $style = "obs";
my $clean = 0;
my $binarylist = "";
my $buildall = 0;
my $dist = "tizen";
my $dryrun = 0;
my $help = 0;
my $keepgoing = 0;

my $build_root = $ENV{TIZEN_BUILD_ROOT};
my $localrepo = "$build_root/local/repos";
my $order_dir = "$build_root/local/order";

my_mkdir($order_dir);

my $cache_dir = "$build_root/local/cache";
my $groupfile="$build_root/meta/group.xml";
my $virtualenv = "$ENV{'VIRTUAL_ENV'}";
my $build_dir = "$virtualenv/usr/lib/build";
my $config_filename = "$build_root/meta/local.conf";
my $dist_configs = "$build_root/meta/dist";
my $man = 0;
my $debug = 0;
my $overwrite = 0;
my $MAX_THREADS = 1;
my $suffix = "";

GetOptions (
    "arch=s" => \$arch,
    "clean" => \$clean,
    "exclude=s" => \@exclude,
    "build-all" => \$buildall,
    "dist=s" => \$dist,
    "binary=s" => \$binarylist,
    "style=s" => \$style,
    "path=s" => \$path,
    "dryrun" => \$dryrun,
    "help|?" => \$help,
    "keepgoing" => \$keepgoing,
    "localrepo=s" => \$localrepo,
    "man" => \$man,
    "overwrite" => \$overwrite,
    "suffix=s" => \$suffix,
    "debug" => \$debug,
    "threads" => \$MAX_THREADS,
    );


my $scratch_dir = "$build_root/local/scratch.$arch";


sub parse_config_file {
    my ($config_line, $Name, $Value);

    my ($File, $Config) = @_;

    if (!open (CONFIG, "$File")) {
        print "ERROR: Config file not found : $File\n";
        exit(0);
    }

    while (<CONFIG>) {
        $config_line=$_;
        chop ($config_line);          # Get rid of the trailling \n
        $config_line =~ s/^\s*//;     # Remove spaces at the start of the line
        $config_line =~ s/\s*$//;     # Remove spaces at the end of the line
        if ( ($config_line !~ /^#/) && ($config_line ne "") ){    # Ignore lines starting with # and blank lines
            ($Name, $Value) = split (/=/, $config_line);          # Split each line into name value pairs
            $Name =~ s/^\s*//;
            $Name =~ s/\s*$//;
            $Value =~ s/\s*$//;
            $Value =~ s/^\s*//;
            $$Config{$Name} = $Value;                             # Create a hash of the name value pairs
        }
    }
    close(CONFIG);
}



my @packs = @ARGV;
my $package_path = "";
# FIXME
my @archs = ("i586", "i686", "noarch");
my %Config = ();
&parse_config_file ($config_filename, \%Config);
#foreach my $Config_key (keys %Config) {
#    print "$Config_key\n";
#    print "$Config_key = $Config{$Config_key}\n";
#}
#exit(1);


sub debug {
    my $msg = shift;
    print YELLOW, "DEBUG: $msg\n", RESET if $debug == 1;
}
sub info {
    my $msg = shift;
    print "$msg\n";
}


if ( $path eq "" ) {
    $package_path = "$build_root/packages";
} else {
    $package_path = $path;
}

if ($binarylist ne "") {
    $buildall = 1;
}

if ($buildall) {
    if ($style eq "git") {
        File::Find::find({wanted => \&git_wanted}, $package_path );
    } elsif ($style eq "obs") {
        File::Find::find({wanted => \&obs_wanted}, $package_path );
    }
} else {
    if (@packs == 0) {
        die("Please provide a list of packages to build.");
    }
}

sub git_wanted {
    my ($dev,$ino,$mode,$nlink,$uid,$gid);

    info("Creating archives from git...");
    /^packaging\z/s &&
    (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &&
    -d _
    && fill_packs_from_git($name);
}

sub obs_wanted {
    /^.*\.spec\z/s && fill_packs_from_obs($name);
}

sub fill_packs_from_obs()
{
    my $name = shift;
    $name =~ m/\.osc/ || push(@packs, $name);
}


sub fill_packs_from_git()
{
    my $name = shift;
    my $pattern = "$name/*.spec";
    my @specs = glob $pattern;
    foreach my $spec (@specs) {
        my $config = Build::read_config_dist($dist, $archs[1], $dist_configs);
        my $pack = Build::Rpm::parse($config, $spec);

        my $pwd = getcwd;
        my $base = dirname($name);
        my $filename = "$name/$pack->{name}-$pack->{version}.tar.bz2";
        debug ("Creating archive $filename");
        system("cd $base; git archive --format=tar --prefix=$pack->{name}-$pack->{version}/ HEAD | bzip2 > $name/$pack->{name}-$pack->{version}.tar.bz2; cd $pwd") if ! -e $filename;
        $filename = "$name/$pack->{name}-$pack->{version}.tar.gz";
        system("cd $base; git archive --format=tar --prefix=$pack->{name}-$pack->{version}/ HEAD | gzip > $name/$pack->{name}-$pack->{version}.tar.gz; cd $pwd") if ! -e $filename;
        push(@packs, $spec);
    }
}


sub parse_packs {
    my @packs = @_;
    my %packs = ();
    foreach my $spec (@packs) {
        my $config = Build::read_config_dist($dist, "i586", $dist_configs);
        my $path_to_spec = "";
        if ( -e $spec ) {
            $path_to_spec =  $spec;
        } else {
            if ( $style eq 'obs') {
                $path_to_spec =  "$package_path/$spec/$spec.spec";
            } else {
                $path_to_spec =  "$package_path/$spec/$spec.spec";
            }
        }
        my $pack = Build::Rpm::parse($config, $path_to_spec);
        debug("path to spec: $path_to_spec");
        my $name = $pack->{name};
        my $version = $pack->{version};
        my $release = $pack->{release};
        my @buildrequires = $pack->{deps};
        my @subpacks = $pack->{subpacks};
        $packs{$name} = {
            name => $name,
            version => $version,
            release => $release,
            deps => @buildrequires,
            subpacks => @subpacks,
            filename => $path_to_spec
        }
    }
    return %packs;
}

sub expand_deps {
    my $rpmdeps = "$order_dir/.repo_assist.cache";
    if ( ! -e $rpmdeps ) {
        my $repo_assist = $Config{main_repo_url};
        if (system("$build_dir/createrepomddeps --cachedir=$order_dir $repo_assist > $rpmdeps ") != 0 ) {
            return 1;
        }
    }
    my (%fn, %prov, %req);

    my %packs;
    my %repo;
    my %ids;

    my %packs_arch;
    my %packs_done;
    open(F, '<', $rpmdeps) || die("$rpmdeps: $!\n");
# WARNING: the following code assumes that the 'I' tag comes last
    my ($pkgF, $pkgP, $pkgR);
    while(<F>) {
      chomp;
      if (/^F:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        $pkgF = $2;
        next if $fn{$1};
        $fn{$1} = $2;
        my $pack = $1;
        $pack =~ /^(.*)\.([^\.]+)$/ or die;
        push @{$packs_arch{$2}}, $1;
      } elsif (/^P:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        $pkgP = $2;
        next if $prov{$1};
        $prov{$1} = $2;
      } elsif (/^R:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        $pkgR = $2;
        next if $req{$1};
        $req{$1} = $2;
      } elsif (/^I:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        if ($ids{$1} && $packs_done{$1} && defined($pkgF) && defined($pkgP) && defined($pkgR)) {
          my $i = $1;
          my $oldid = $ids{$1};
          my $newid = $2;
          if (Build::Rpm::verscmp($oldid, $newid) < 0) {
            $ids{$i}  = $newid;
            $fn{$i}   = $pkgF;
            $prov{$i} = $pkgP;
            $req{$i}  = $pkgR;
          }
        } else {
          next if $ids{$1};
          $ids{$1} = $2;
        }
        undef $pkgF;
        undef $pkgP;
        undef $pkgR;
      } elsif ($_ eq 'D:') {
        %packs_done = %ids;
      }
    }
    close F;

    for my $arch (@archs) {
      $packs{$_} ||= "$_.$arch" for @{$packs_arch{$arch} || []};
    }

    my $cf = Build::read_config_dist($dist, $archs[0], $dist_configs);
    $cf->{'warnings'} = 1;

    my $dofileprovides = %{$cf->{'fileprovides'}};

    for my $pack (keys %packs) {
      my $r = {};
      my (@s, $s, @pr, @re);
      @s = split(' ', $prov{$packs{$pack}} || '');
      while (@s) {
        $s = shift @s;
        next if !$dofileprovides && $s =~ /^\//;
        if ($s =~ /^rpmlib\(/) {
          splice(@s, 0, 2);
          next;
        }
        push @pr, $s;
        splice(@s, 0, 2) if @s && $s[0] =~ /^[<=>]/;
      }
      @s = split(' ', $req{$packs{$pack}} || '');
      while (@s) {
        $s = shift @s;
        next if !$dofileprovides && $s =~ /^\//;
        if ($s =~ /^rpmlib\(/) {
          splice(@s, 0, 2);
          next;
        }
        push @re, $s;
        splice(@s, 0, 2) if @s && $s[0] =~ /^[<=>]/;
      }
      $r->{'provides'} = \@pr;
      $r->{'requires'} = \@re;
      $repo{$pack} = $r;
    }
    return %repo;
}



my %packs = parse_packs(@packs);


my @tobuild = ();
my @tofind = ();
my @final = ();
if ($binarylist ne "" && -e $binarylist ) 
{
    my %repo_assist = expand_deps();

    open FILE, "<", $binarylist or die $!;
    my @bins = <FILE>;
    chomp(@bins);
    close(FILE);
    foreach my $b (@bins) {
        next if $b eq "";
        my $found = 0;
        foreach my $name (keys %packs) {
            my @sp = @{$packs{$name}->{subpacks}};
            my $debuginfo = $b;
            $debuginfo =~ s/(.*)-debuginfo/$1/;
            $debuginfo =~ s/(.*)-debugsource/$1/;
            $debuginfo =~ s/(.*)-docs/$1/;
            my $nb;
            if ($b ne $debuginfo) { 
                $nb = $debuginfo;
            } else {
                $nb = $b;
            }
            if ( grep $_ eq $nb, @sp ) {
                push(@tobuild, $name);
                $found = 1 ;
                last;
            } 
        }
        if (!$found) {
            push(@tofind, $b);
        }
    }

    print "Initial set:\n";
    foreach my $p (@tobuild) {
        print "$p, ";
    }
    print "\n";

    foreach my $p (@tobuild) {
        my @deps = @{$packs{$p}->{deps}};    
        foreach my $dep (@deps) {
            foreach my $prr (keys %repo_assist) {
                if (grep $_ eq $dep, @{$repo_assist{$prr}->{provides}}) {
                    my $mainp = source_of($prr, %packs);
                    if (defined($mainp)) {
                        push(@tobuild, $mainp);
                        debug("adding $mainp because $p needs it");
                    }
                }
            }
        }
    }
    print "Improved set:\n";
    foreach my $p (@tobuild) {
        print "$p, ";
    }
    print "\n";
    #foreach my $p (@tobuild) {
    #    foreach my $req (@{$repo_assist{$prr}->{requires}}) {
    #    }
    #}

    foreach my $name (@tobuild) {
        my $fn = $packs{$name}->{filename};
        push(@final, $fn);
    }

    print "Still " . ($#tofind + 1 ) . " to find:\n";
    print "Check if binaries are provided by a repo\n";
    my $rpmdeps = "$order_dir/.repo.cache";
    open(F, '<', $rpmdeps) || die("$rpmdeps: $!\n");
    my @bindeps = <F>;
    close(F);
    chomp(@bindeps);
    my @tofind_2 = ();
    foreach my $missing (@tofind) {
        print "Checking for $missing: ";
        if ( grep /^I:$missing.(i586|i686|noarch)-.*/, @bindeps ) {
            print "provided as binary, skipping...\n";
        } else {
            print "can't be found.\n";
            push(@tofind_2, $missing);
        }
    }
    if ($#tofind_2 > 0 ) {
        print "Still " . ($#tofind_2 + 1 ) . " to find:\n";
    }
    foreach my $m (@tofind_2) {
        print $m . "\n";
    }
} elsif ( $binarylist ne "") {
    print "Cant find binary list for image\n";
    exit 1;
}




sub source_of {
    my ($sub, %packs) = @_;
    foreach my $x (keys %packs) {
        my @sp = @{$packs{$x}->{subpacks}};
        if (grep $_ eq $sub, @sp ) {
            return $x;
        }
    }
    return undef;
}

my %to_build = ();
if ($binarylist ne "") {
    %to_build = parse_packs(@final);
} else {
    %to_build = parse_packs(@packs);
}

sub my_mkdir
{
    local $_ = $_[0];

    if (! -d $_) {
        mkdir ($_, 0755) or die "mkdir $_: $!"
    }
}

sub createrepo
{
    my $arch = shift;
    my $dist = shift;

    my_mkdir "$localrepo";
    my_mkdir "$localrepo/$dist";
    my_mkdir "$localrepo/$dist/src";
    my_mkdir "$localrepo/$dist/src/SRPMS";
    system ("cd $localrepo/$dist/src && rm -rf repodata && createrepo --changelog-limit=0 -q . > /dev/null 2>&1 ") == 0
        or die "createrepo failed: $?\n";

    my_mkdir "$localrepo/$dist/$arch";
    my_mkdir "$localrepo/$dist/$arch/RPMS";
    my_mkdir "$localrepo/$dist/$arch/logs";

    
    my $groups = "";
    if ( -e $groupfile ) {
        $groups = " --groupfile=$groupfile ";
    }

    system ("cd $localrepo/$dist/$arch && rm -rf repodata && createrepo $groups --changelog-limit=0 -q --exclude 'logs/*rpm' . > /dev/null 2>&1 ") == 0
        or die "createrepo failed: $?\n";
}

my @errors :shared;

my %workers = ();

for(my $w = 0; $w < $MAX_THREADS; $w++) {
    $workers{$w} = { 'state' => 'idle' , 'tid' => undef };
}

sub find_idle {
    my $idle = -1;
    foreach my $w (keys %workers) {
        my $tid = $workers{$w}->{tid};
        my $state = $workers{$w}->{state};
        if (! defined(threads->object($tid))) {
            set_idle($w);
            $idle = $w;
            last;
        }
    }
    foreach my $w (keys %workers) {
        if ( $workers{$w}->{state} eq 'idle' ) {
            $idle = $w;
            last;
        }
    }
    return $idle;
}

sub set_busy {
    my $worker = shift;
    my $thread = shift;
    $workers{$worker} = { 'state' => 'busy', 'tid' => $thread };
}

sub set_idle {
    my $worker = shift;
    $workers{$worker} = { 'state' => 'idle' , 'tid' => undef};
}

my $packages_built :shared  = 0;

sub build_package {
    my ($name, $thread) = @_;
    use vars qw($repo);
    #{
    #    lock($DETACHING);
    #    threads->detach() if ! threads->is_detached();
    #}
    #return(0);

    my $version = $to_build{$name}->{version};
    my $release = $to_build{$name}->{release};
    my $srpm_filename = $to_build{$name}->{filename};

    # Rebuild the package.
    print "*** building $name-$version-$release $arch $dist (worker: $thread) ***\n";

    $ENV{'BUILD_DIR'} = $build_dir;

    my $repos = "";
    if ( -d "$localrepo/$dist/$arch/RPMS" ) {
        $repos .= "--rpms $localrepo/$dist/$arch/RPMS ";
    }
    $repos .= "--repository $repo ";

    my $clean_option = "";
    if ($clean) {
       $clean_option = " --clean "; 
    }
    my $scratch = "$scratch_dir.$thread";

    my $buildcmd = "sudo BUILD_ROOT=$scratch BUILD_DIR=\"$build_dir\" build --jobs 4 $clean_option --cachedir $cache_dir --dist $dist --configdir $dist_configs $repos $srpm_filename > /dev/null 2>&1  ";
    debug("$buildcmd");
    if (system ($buildcmd) == 0 ) {
        system ("cp $scratch/home/abuild/rpmbuild/SRPMS/*.rpm $localrepo/$dist/src/SRPMS") == 0 or die "mv";
        system ("cp $scratch/home/abuild/rpmbuild/RPMS/*/*.rpm $localrepo/$dist/$arch/RPMS") == 0 or die "mv";
        my_mkdir "$localrepo/$dist/$arch/logs/$name-$version-$release";
        system ("cp $scratch/.build.log $localrepo/$dist/$arch/logs/$name-$version-$release/log") == 0 or die "mv";
        system ("cp $scratch/.srcfiles.cache $order_dir/.repo.cache") == 0 or die "mv";
        # Detach and terminate
        {
            lock($DETACHING);
            threads->detach() if ! threads->is_detached();
        }
        print GREEN, "finished building $name\n", RESET;
        $packages_built = 1;
        return(0);
    } else {
        my_mkdir "$localrepo/$dist/$arch/logs/$name-$version-$release";
        if ( -f "$scratch/.build.log" ) {
            system ("cp $scratch/.build.log $localrepo/$dist/$arch/logs/$name-$version-$release/log") == 0 or die "cp";
            print RED, "Build failed, Leaving the logs in $localrepo/$dist/$arch/logs/$name-$version-$release/log\n", RESET;
        }
        push @errors, "$name-$dist-$arch$suffix";
        # Detach and terminate
        {
            lock($DETACHING);
            threads->detach() if ! threads->is_detached();
        }
        return 1;
    }

}

my @done = ();
my %caught;
if ( ! -e "$localrepo/$dist/$arch/RPMS" ) {
    createrepo ($arch, $dist);
}
while (1) {
    my @order = ();
    our $repo = $Config{base_repo_url};
    my $cmd = "$build_dir/createrepomddeps --cachedir=$order_dir $repo > $order_dir/.repo.cache ";
    debug($cmd);
    if ( ( system($cmd) == 0 ) &&
        system("$build_dir/createrpmdeps $localrepo/$dist/$arch/RPMS >> $order_dir/.repo.cache ") == 0 ) {
        foreach my $name (keys %to_build) {
            if( ! (grep $_ eq $name, @done) && ! (grep $_ eq $name, @exclude)) {
                my $fn = $to_build{$name}->{filename};
                my $version = $to_build{$name}->{version};
                my $release = $to_build{$name}->{release};
                my $pattern = "$localrepo/$dist/src/SRPMS/$name-$version-$release.*.rpm";
                my @binaries = glob $pattern;
                if (@binaries != 0 && $overwrite) {
                    print "*** overwriting $name-$version-$release $arch $dist ***\n";
                }
                if (@binaries == 0 || $overwrite) {
                    debug("Checking dependencies for $name");
                    my $dd = "";
                    if ( $debug ) {
                        $dd = "--debug";
                    }
                    if ( system("$virtualenv/usr/bin/check_unresolved $dd --depfile $order_dir/.repo.cache --configdir $dist_configs --dist $dist --archpath i586:i686:noarch $fn") == 0 ) {
                        push(@order, $name);
                    }

                } else {
                    debug("skipping $name-$version-$release $arch $dist");
                }
            }
        }
    } else {
        print "repo cache creation failed...\n";
        exit(1);
    }
    if (@order == 0) {
        last;
    } else {
        push(@done, @order);
        debug("Next pass:");
        foreach my $o (@order) {
            debug($o);
        }
    }
    if ($dryrun) {
        exit 1
    }

    while (@order && ! $TERM) {
        # Keep max threads running
        for (my $needed = $MAX_THREADS - threads->list(); 
            $needed && ! $TERM; $needed--) {

            my $job = shift(@order);
            last if (! $job);


            my $worker = find_idle();
            my $thr = threads->create('build_package',$job, $worker);
            my $tid = $thr->tid();
            set_busy($worker, $tid);
        }
    }

    while ((threads->list() > 0)) {
        # waiting for threads to finish
        sleep(1);
    }

}

if ($packages_built) {
    createrepo ($arch, $dist);
}

if (@errors) {
    print "\n\n\nBuild failed for the following packages:\n";
    print "  $_\n" foreach @errors;
    exit 1
}

exit 0
