#!/usr/bin/perl 
#
BEGIN {
  my ($wd) = $0 =~ m-(.*)/- ;
  $wd ||= '.';
  unshift @INC,  "$wd/build";
  unshift @INC,  "$wd";
  unshift @INC,  "$ENV{'VIRTUAL_ENV'}/usr/lib/build"
}

use strict;
use YAML qw(LoadFile);
use warnings;
use threads;
use threads::shared;
use File::Find ();
use Term::ANSIColor qw(:constants);
use File::Path;
use File::Basename;
use URI;

# Global vars


# Flag to inform all threads that application is terminating
my $TERM:shared=0;

# Prevents double detach attempts
my $DETACHING:shared;

# Signal handling
$SIG{'INT'} = $SIG{'TERM'} = sub {
        print("^C captured\n");
        $TERM=1;
};

# Set the variable $File::Find::dont_use_nlink if you're using AFS,
# since AFS cheats.

# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

my ($zname, $zpass, $zuid, $zgid, $zquota, $zcomment, $zgcos, $zdir, $zshell, $zexpire) = getpwnam(getlogin());

sub wanted;


use Cwd;
use Getopt::Long;
use Pod::Usage;
use File::Temp qw(tempfile);
use Build;
use Build::Rpm;
use Data::Dumper;
use File::Basename;

my @threads;
my @exclude = ();
my $arch = "i586";
my $path = "";
my $style = "git";
my $clean = 0;
my $binarylist = "";
my $buildall = 0;
my $dist = "tizen";
my $dryrun = 0;
my $help = 0;
my $keepgoing = 0;

my $build_root = $ENV{TIZEN_BUILD_ROOT};
my $localrepo = "$build_root/local/repos";
my $order_dir = "$build_root/local/order";


my $cache_dir = "$build_root/local/cache";
my $groupfile="$build_root/meta/group.xml";
my $virtualenv = "$ENV{'VIRTUAL_ENV'}";
my $build_dir = "$virtualenv/usr/lib/build";
my $config_filename = "$build_root/meta/local.yaml";
my $dist_configs = "$build_root/meta/dist";
my $man = 0;
my $cleanonce = 0;
my $debug = 0;
my $incremental = 0;
my $overwrite = 0;
my $MAX_THREADS = 1;
my $suffix = "";
my @cleaned : shared = ();
my $exclude_from_file = "$build_root/meta/exclude";

GetOptions (
    "arch=s" => \$arch,
    "clean" => \$clean,
    "clean-once" => \$cleanonce,
    "exclude=s" => \@exclude,
    "exclude-from-file=s" => \$exclude_from_file,
    "build-all" => \$buildall,
    "dist=s" => \$dist,
    "binary=s" => \$binarylist,
    "style=s" => \$style,
    "path=s" => \$path,
    "dryrun" => \$dryrun,
    "help|?" => \$help,
    "keepgoing" => \$keepgoing,
    "localrepo=s" => \$localrepo,
    "man" => \$man,
    "overwrite" => \$overwrite,
    "suffix=s" => \$suffix,
    "debug" => \$debug,
    "incremental" => \$incremental,
    "threads=s" => \$MAX_THREADS,
    );


my $scratch_dir = "$build_root/local/scratch.$arch";

if ( $exclude_from_file ne "" && -e $exclude_from_file ) {
    debug("using $exclude_from_file for package exclusion");
    open FILE, "<", $exclude_from_file  or die $!;
    @exclude = <FILE>;
    chomp(@exclude);
    close(FILE);
}


sub mkdir_p($) {
    my $path = shift;
    my $err_msg;
# attempt a 'mkdir -p' on the provided path and catch any errors returned
    my $mkdir_out = File::Path::make_path( $path, { error => \my $err } );
# catch and return the error if there was one
    if (@$err) {
        for my $diag (@$err) {
            my ( $file, $message ) = %$diag;
            $err_msg .= $message;
        }
        print STDERR "$err_msg";
    }
} 

mkdir_p($order_dir);


my @packs = @ARGV;
my $package_path = "";
# FIXME
my @archs = ("i586", "i686", "noarch");
my $archpath;
foreach my $ap (@archs) {
    $archpath .= $ap.":"; 
}

my $Config = LoadFile($config_filename);
my @package_repos = ();
foreach my $r (@{$Config->{Repositories}}) {
    my $uri = URI->new($r->{Url});
    if ( $r->{Password} && $r->{Username} ) {
        $uri->userinfo($r->{Username} . ":" . $r->{Password});
    }
    if ($uri->scheme ne "file") {
        push(@package_repos, $uri);
    }
}



sub debug {
    my $msg = shift;
    $msg =~ s#://[^@]*@#://#g;
    print YELLOW, "DEBUG: $msg\n", RESET if $debug == 1;
}
sub info {
    my $msg = shift;
    print GREEN, "$msg\n", RESET;
}

if ( -d "packaging" && -d ".git" ) {
    $path = cwd();
}
if ( $path eq "" ) {
    $package_path = "$build_root/packages";
} else {
    $package_path = $path;
}

print "Start building packages from: " . $package_path . " ($style)\n";

if ($binarylist ne "") {
    $buildall = 1;
}

if ($buildall || @packs == 0 ) {
    if ($style eq "git") {
        File::Find::find({wanted => \&git_wanted}, $package_path );
    } elsif ($style eq "obs") {
        File::Find::find({wanted => \&obs_wanted}, $package_path );
    }
} else {
    if (@packs == 0 && $path eq "") {
        print "Please provide a list of packages to build.";
        exit 1;
    }
}

sub git_wanted {
    my ($dev,$ino,$mode,$nlink,$uid,$gid);
    /^packaging\z/s &&
    (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &&
    -d _
    && fill_packs_from_git($name);
}


sub obs_wanted {
    /^.*\.spec\z/s && fill_packs_from_obs($name);
}

sub fill_packs_from_obs() {
    my $name = shift;
    $name =~ m/\.osc/ || push(@packs, $name);
}

sub fill_packs_from_git() {
    my $name = shift;
    my $base = dirname($name);
    if ( ! -e "$base/.git" ) {
        debug("$base is not a git checkout");
        return;
    }
    my $prj = basename($base);
    if ( (grep $_ eq $prj, @exclude) ) {
        return;
    }
    debug("working on $base");
    my $pkg_path = "$build_root/local/sources/$dist";
    my $cache_path = "$build_root/local/sources/$dist/cache";
    mkdir_p($cache_path);
    my $pattern = "$name/*.spec";
    my @specs = glob $pattern;
    my $spec = "";
    if (@specs > 1 ) {
        if ( -e "$name/$prj.spec" ) {
            $spec = "$name/$prj.spec";
        } else {
            return;
        }
    } elsif (@specs) {
        $spec = $specs[0];
    } else {
        return;
    }
    my $config = Build::read_config_dist($dist, "i586", $dist_configs);
    my $pack = Build::Rpm::parse($config, $spec);
    my $pkg_name = $pack->{name};
    my $pkg_version = $pack->{version};
    my $pkg_release = $pack->{release};
    my $spec_file = basename($spec);
    my $skip = 0;
    my $old_base = "";
    if ( -e "$base/.git" ) {
        open(GIT,"git --git-dir $base/.git rev-parse  HEAD |") || die "Failed: $!\n";
        while (my $current_rev = <GIT>) {
            chomp($current_rev);
            if ( system("grep -rq $current_rev $cache_path") == 0 ) {
               open(GREP,"grep -rl $current_rev $cache_path |") || die "Failed: $!\n";
               while ( <GREP> ) {
                    chomp;
                   $old_base = $_;
               }
               close(GREP);
               $skip = 1;
            }
            my @lines = ();
            if ( -e "$cache_path/$pkg_name-$pkg_version-$pkg_release" ) {
                open (REV, "< $cache_path/$pkg_name-$pkg_version-$pkg_release");
                @lines = <REV>;
            } else {
                open (REV, "> $cache_path/$pkg_name-$pkg_version-$pkg_release");
            }
            foreach my $old_rev(@lines) {
                if ( $current_rev eq $old_rev ) {
                    $skip = 1;
                }
            }
            close (REV); 
            open (REV1, "+> $cache_path/$pkg_name-$pkg_version-$pkg_release");
            print REV1 $current_rev . "\n";
            close (REV1); 
        }
        close(GIT);
    } else {
        debug("not a git repo: $base/.git!!");
    }
    if ($skip == 1) {
        if ( $old_base ne "" ) {
            $old_base = basename($old_base);
            push(@packs, "$pkg_path/$old_base/$spec_file");
        } else {
            push(@packs, "$pkg_path/$pkg_name-$pkg_version-$pkg_release/$spec_file");
        }
    } else {
        if ( system("gbs export  $base -o $pkg_path") == 0 ) {
            push(@packs, "$pkg_path/$pkg_name-$pkg_version-$pkg_release/$spec_file");
        } else {
            debug("$name was not exported correctly");
        }
    }
}


sub parse_packs {
    my @packs = @_;
    my %packs = ();
    foreach my $spec (@packs) {
        my $config = Build::read_config_dist($dist, "i586", $dist_configs);
        my $path_to_spec = "";
        if ( -e $spec ) {
            $path_to_spec =  $spec;
        } else {
            if ( $style eq 'obs') {
                $path_to_spec =  "$package_path/$spec/$spec.spec";
            } else {
                $path_to_spec =  "$package_path/$spec/$spec.spec";
            }
        }
        my $pack = Build::Rpm::parse($config, $path_to_spec);
        if ( ( $pack->{'exclarch'} ) && ( ! grep $_ eq $arch, $pack->{'exclarch'} ) ) {
            next;
        }
        debug("path to spec: $path_to_spec");
        my $name = $pack->{name};
        my $version = $pack->{version};
        my $release = $pack->{release};
        my @buildrequires = $pack->{deps};
        my @subpacks = $pack->{subpacks};
        $packs{$name} = {
            name => $name,
            version => $version,
            release => $release,
            deps => @buildrequires,
            subpacks => @subpacks,
            filename => $path_to_spec
        }
    }
    return %packs;
}

sub expand_deps {
    my $rpmdeps = "$order_dir/.repo.cache";
    if ( ! -e $rpmdeps ) {
        #my $repo_assist = $Config{main_repo_url};
        #debug("retrieving dependency data from server....");
        #if (system("$build_dir/createrepomddeps --cachedir=$order_dir $repo_assist > $rpmdeps ") != 0 ) {
        #    return 1;
        #}
    }
    my (%fn, %prov, %req);

    my %packs;
    my %repo;
    my %ids;

    my %packs_arch;
    my %packs_done;
    open(F, '<', $rpmdeps) || die("$rpmdeps: $!\n");
# WARNING: the following code assumes that the 'I' tag comes last
    my ($pkgF, $pkgP, $pkgR);
    while(<F>) {
      chomp;
      if (/^F:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        $pkgF = $2;
        next if $fn{$1};
        $fn{$1} = $2;
        my $pack = $1;
        $pack =~ /^(.*)\.([^\.]+)$/ or die;
        push @{$packs_arch{$2}}, $1;
      } elsif (/^P:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        $pkgP = $2;
        next if $prov{$1};
        $prov{$1} = $2;
      } elsif (/^R:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        $pkgR = $2;
        next if $req{$1};
        $req{$1} = $2;
      } elsif (/^I:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        if ($ids{$1} && $packs_done{$1} && defined($pkgF) && defined($pkgP) && defined($pkgR)) {
          my $i = $1;
          my $oldid = $ids{$1};
          my $newid = $2;
          if (Build::Rpm::verscmp($oldid, $newid) < 0) {
            $ids{$i}  = $newid;
            $fn{$i}   = $pkgF;
            $prov{$i} = $pkgP;
            $req{$i}  = $pkgR;
          }
        } else {
          next if $ids{$1};
          $ids{$1} = $2;
        }
        undef $pkgF;
        undef $pkgP;
        undef $pkgR;
      } elsif ($_ eq 'D:') {
        %packs_done = %ids;
      }
    }
    close F;

    for my $arch (@archs) {
      $packs{$_} ||= "$_.$arch" for @{$packs_arch{$arch} || []};
    }

    my $cf = Build::read_config_dist($dist, $archs[0], $dist_configs);
    $cf->{'warnings'} = 1;

    my $dofileprovides = %{$cf->{'fileprovides'}};

    for my $pack (keys %packs) {
      my $r = {};
      my (@s, $s, @pr, @re);
      @s = split(' ', $prov{$packs{$pack}} || '');
      while (@s) {
        $s = shift @s;
        next if !$dofileprovides && $s =~ /^\//;
        if ($s =~ /^rpmlib\(/) {
          splice(@s, 0, 2);
          next;
        }
        push @pr, $s;
        splice(@s, 0, 2) if @s && $s[0] =~ /^[<=>]/;
      }
      @s = split(' ', $req{$packs{$pack}} || '');
      while (@s) {
        $s = shift @s;
        next if !$dofileprovides && $s =~ /^\//;
        if ($s =~ /^rpmlib\(/) {
          splice(@s, 0, 2);
          next;
        }
        push @re, $s;
        splice(@s, 0, 2) if @s && $s[0] =~ /^[<=>]/;
      }
      $r->{'provides'} = \@pr;
      $r->{'requires'} = \@re;
      $repo{$pack} = $r;
    }
    return %repo;
}



print "Parsing package data...\n";
my %packs = parse_packs(@packs);


my @tobuild = ();
my @tofind = ();
my @final = ();
if ($binarylist ne "" && -e $binarylist ) 
{
    my %repo_assist = expand_deps();

    open FILE, "<", $binarylist or die $!;
    my @bins = <FILE>;
    chomp(@bins);
    close(FILE);
    foreach my $b (@bins) {
        next if $b eq "";
        my $found = 0;
        foreach my $name (keys %packs) {
            my @sp = @{$packs{$name}->{subpacks}};
            my $debuginfo = $b;
            $debuginfo =~ s/(.*)-debuginfo/$1/;
            $debuginfo =~ s/(.*)-debugsource/$1/;
            $debuginfo =~ s/(.*)-docs/$1/;
            my $nb;
            if ($b ne $debuginfo) { 
                $nb = $debuginfo;
            } else {
                $nb = $b;
            }
            if ( grep $_ eq $nb, @sp ) {
                push(@tobuild, $name);
                $found = 1 ;
                last;
            } 
        }
        if (!$found) {
            push(@tofind, $b);
        }
    }

    print "Initial set:\n";
    foreach my $p (@tobuild) {
        print "$p, ";
    }
    print "\n";
    foreach my $p (@tobuild) {
        my @deps = @{$packs{$p}->{deps}};    
        foreach my $dep (@deps) {
            debug($dep);
            foreach my $prr (keys %repo_assist) {
                debug("=> " . $prr);
                $dep =~ m/([^\s]+)/;
                if (grep $_ eq $1, @{$repo_assist{$prr}->{provides}}) {
                    my $mainp = source_of($1, %packs);
                    if (defined($mainp)) {
                        debug("adding $mainp because $p needs it");
                        push(@tobuild, $mainp);
                    }
                }
            }
        }
    }
    debug("done");
    print "Improved set:\n";
    foreach my $p (@tobuild) {
        print "$p, ";
    }
    print "\n";
    #foreach my $p (@tobuild) {
    #    foreach my $req (@{$repo_assist{$prr}->{requires}}) {
    #    }
    #}

    foreach my $name (@tobuild) {
        my $fn = $packs{$name}->{filename};
        push(@final, $fn);
    }

    debug("Still " . ($#tofind + 1 ) . " to find:");
    debug("Check if binaries are provided by a repo");
    if ( ! -e "$order_dir/.repo.cache" ) {
        system("> $order_dir/.repo.cache");
        foreach my $repo (@package_repos) {
            my $cmd = "$build_dir/createrepomddeps --cachedir=$order_dir $repo >> $order_dir/.repo.cache ";
            system($cmd);
        }
    }
    my $rpmdeps = "$order_dir/.repo.cache";
    open(F, '<', $rpmdeps) || die("$rpmdeps: $!\n");
    my @bindeps = <F>;
    close(F);
    chomp(@bindeps);
    my @tofind_2 = ();
    foreach my $missing (@tofind) {
        debug("Checking for $missing: ");
        if ( grep /^I:$missing.(i586|i686|noarch)-.*/, @bindeps ) {
            debug("provided as binary, skipping...");
        } else {
            debug("can't be found.");
            push(@tofind_2, $missing);
        }
    }
    if ($#tofind_2 > 0 ) {
        debug("Still " . ($#tofind_2 + 1 ) . " to find:");
    }
    foreach my $m (@tofind_2) {
        debug($m);
    }
} elsif ( $binarylist ne "") {
    print STDERR "Cant find binary list for image\n";
    exit 1;
}




sub source_of {
    my ($sub, %packs) = @_;
    foreach my $x (keys %packs) {
        my @sp = @{$packs{$x}->{subpacks}};
        if (grep $_ eq $sub, @sp ) {
            return $x;
        }
    }
    return undef;
}

my %to_build = ();
if ($binarylist ne "") {
    %to_build = parse_packs(@final);
} else {
    %to_build = parse_packs(@packs);
}



sub createrepo
{
    my $arch = shift;
    my $dist = shift;

    mkdir_p "$localrepo/$dist/src/SRPMS";
    system ("cd $localrepo/$dist/src && rm -rf repodata && createrepo --changelog-limit=0 -q . > /dev/null 2>&1 ") == 0
        or die "createrepo failed: $?\n";

    mkdir_p "$localrepo/$dist/$arch/RPMS";

    
    my $groups = "";
    if ( -e $groupfile ) {
        $groups = " --groupfile=$groupfile ";
    }

    system ("cd $localrepo/$dist/$arch && rm -rf repodata && createrepo $groups --changelog-limit=0 -q --exclude 'logs/*rpm' . > /dev/null 2>&1 ") == 0
        or die "createrepo failed: $?\n";
}

my @errors :shared;

my %workers = ();

for(my $w = 0; $w < $MAX_THREADS; $w++) {
    $workers{$w} = { 'state' => 'idle' , 'tid' => undef };
}

sub find_idle {
    my $idle = -1;
    foreach my $w (keys %workers) {
        my $tid = $workers{$w}->{tid};
        my $state = $workers{$w}->{state};
        if (! defined(threads->object($tid))) {
            set_idle($w);
            $idle = $w;
            last;
        }
    }
    foreach my $w (keys %workers) {
        if ( $workers{$w}->{state} eq 'idle' ) {
            $idle = $w;
            last;
        }
    }
    return $idle;
}

sub set_busy {
    my $worker = shift;
    my $thread = shift;
    $workers{$worker} = { 'state' => 'busy', 'tid' => $thread };
}

sub set_idle {
    my $worker = shift;
    $workers{$worker} = { 'state' => 'idle' , 'tid' => undef};
}

my $packages_built :shared  = 0;

sub build_package {
    my ($name, $thread) = @_;
    use vars qw(@package_repos);
    #{
    #    lock($DETACHING);
    #    threads->detach() if ! threads->is_detached();
    #}
    #return(0);

    my $version = $to_build{$name}->{version};
    my $release = $to_build{$name}->{release};
    my $spec_name = basename($to_build{$name}->{filename});
    my $pkg_path = "$build_root/local/sources/$dist/$name-$version-$release";
    my $srpm_filename = "";
    if ( $style eq "git" ) {
        $srpm_filename = "$pkg_path/$spec_name";
    } else {
        $srpm_filename = $to_build{$name}->{filename};
    }

    # Rebuild the package.
    print "*** building $name-$version-$release $arch $dist (worker: $thread) ***\n";

    $ENV{'BUILD_DIR'} = $build_dir;

    my $repos = "";
    if ( -d "$localrepo/$dist/$arch/RPMS" ) {
        $repos .= "--rpms $localrepo/$dist/$arch/RPMS ";
    }
    foreach my $r (@package_repos) {
        $repos .= "--repository $r ";
    }

    my $clean_option = "";
    if ( ($clean || $cleanonce ) && ( ! grep $_ == $thread, @cleaned) )  {
       $clean_option = " --clean "; 
       if ($cleanonce) {
            push(@cleaned, $thread);
       }
    }
    my $scratch = "$scratch_dir.$thread";

    my $redirect = "";
    if ($MAX_THREADS > 1 ) {
        $redirect = "> /dev/null 2>&1";
    }
    my $buildcmd = "sudo BUILD_ROOT=$scratch BUILD_DIR=\"$build_dir\" $virtualenv/usr/bin/build --uid $zuid:$zgid --jobs 4 $clean_option --cachedir $cache_dir --dist $dist --configdir $dist_configs $repos $srpm_filename $redirect  ";
    debug("$buildcmd");
    if (system ($buildcmd) == 0 ) {
        system ("cp $scratch/home/abuild/rpmbuild/SRPMS/*.rpm $localrepo/$dist/src/SRPMS") == 0 or die "mv";
        system ("cp $scratch/home/abuild/rpmbuild/RPMS/*/*.rpm $localrepo/$dist/$arch/RPMS") == 0 or die "mv";
        mkdir_p "$localrepo/$dist/$arch/logs/success/$name-$version-$release";
        system ("cp $scratch/.build.log $localrepo/$dist/$arch/logs/success/$name-$version-$release/log") == 0 or die "mv";
        system ("cp $scratch/.srcfiles.cache $order_dir/.repo.cache") == 0 or die "mv";
        # Detach and terminate
        {
            lock($DETACHING);
            threads->detach() if ! threads->is_detached();
        }
        print GREEN, "finished building $name\n", RESET;
        $packages_built = 1;
        return(0);
    } else {
        mkdir_p "$localrepo/$dist/$arch/logs/fail/$name-$version-$release";
        if ( -f "$scratch/.build.log" ) {
            system ("cp $scratch/.build.log $localrepo/$dist/$arch/logs/fail/$name-$version-$release/log") == 0 or die "cp";
            print RED, "Build failed, Leaving the logs in $localrepo/$dist/$arch/logs/fail/$name-$version-$release/log\n", RESET;
        }
        push @errors, "$name-$dist-$arch$suffix";
        # Detach and terminate
        {
            lock($DETACHING);
            threads->detach() if ! threads->is_detached();
        }
        return 1;
    }

}

my @done = ();
my @skipped = ();
my %caught;
if ( ! -e "$localrepo/$dist/$arch/RPMS" ) {
    print "Creating repo...";
    createrepo ($arch, $dist);
}
mkdir_p "$localrepo/$dist/$arch/logs/success";
mkdir_p "$localrepo/$dist/$arch/logs/fail";

while (! $TERM) {
    my @order = ();
    my $repos_setup = 1;
    system("> $order_dir/.repo.cache");
    if ( system("$build_dir/createrpmdeps $localrepo/$dist/$arch/RPMS >> $order_dir/.repo.cache ") != 0 ) {
        $repos_setup = 0;
    }
    system("echo D: >> $order_dir/.repo.cache");
    foreach my $repo (@package_repos) {
        my $cmd = "$build_dir/createrepomddeps --cachedir=$order_dir $repo >> $order_dir/.repo.cache ";
        debug($cmd);
        if ( system($cmd) == 0 ) {
            system("echo D: >> $order_dir/.repo.cache");
        } else {
            $repos_setup = 0;
        }
    }
    if ($repos_setup == 0 ) {
        print "repo cache creation failed...\n";
        exit(1);
    }
    foreach my $name (keys %to_build) {
        if( ! (grep $_ eq $name, @done) && ! (grep $_ eq $name, @exclude)) {
            my $fn = $to_build{$name}->{filename};
            my $version = $to_build{$name}->{version};
            my $release = $to_build{$name}->{release};
            my $pattern = "$localrepo/$dist/src/SRPMS/$name-$version-$release.*.rpm";
            my @binaries = glob $pattern;
            if (@binaries != 0 && ! $overwrite) {
                info("skipping $name-$version-$release $arch $dist");
                push(@skipped, $name);
            } elsif (@binaries != 0 && $overwrite) {
                print "*** overwriting $name-$version-$release $arch $dist ***\n";
            }
        }
    }
    foreach my $name (keys %to_build) {
        if( ! (grep $_ eq $name, @done) && ! (grep $_ eq $name, @exclude) && ! (grep $_ eq $name, @skipped)) {
            my $fn = $to_build{$name}->{filename};
            my $version = $to_build{$name}->{version};
            my $release = $to_build{$name}->{release};
            my $pattern = "$localrepo/$dist/src/SRPMS/$name-$version-$release.*.rpm";
            my @binaries = glob $pattern;
            if (@binaries == 0 || $overwrite) {
                debug("Checking dependencies for $name");
                my $dd = "";
                if ( $debug ) {
                    $dd = "--debug";
                }
                if ( system("$virtualenv/usr/bin/check_unresolved $dd --depfile $order_dir/.repo.cache --configdir $dist_configs --dist $dist --archpath $archpath $fn") == 0 ) {
                    my $stop =  0;
                    my @deps = @{$to_build{$name}->{deps}};
                    debug("now looking into $name");
                    foreach my $dep (@deps) {
                        open(EXPAND,"$virtualenv/usr/bin/do_expanddeps --dist $dist --depfile $order_dir/.repo.cache --archpath $archpath --configdir $dist_configs \"$dep\" |") || die "Failed: $!\n";
                        while ( <EXPAND> ) {
                            chomp;
                            my $ddep = $_;
                            my $so = source_of($ddep, %to_build);
                            if ( defined($so) && ($so ne $name) && (! grep($_ eq $so, @skipped)) && (! grep($_ eq $so, @done)) ) {
                                debug("Not adding $name for now, it needs $dep -> $ddep ($so)...");
                                $stop = 1;
                            }
                        } 
                        close(EXPAND);

#                        foreach my $n2 (keys %to_build) {
#                            my @subs = @{$to_build{$n2}->{subpacks}};
#                            if (! grep($_ eq $n2, @done)) {
#                                foreach my $sub (@subs) {
#                                    my $so = source_of($sub, %to_build);
#                                    $dep =~ m/([^\s]+).*/;
#                                    if ( $sub eq $1 && ! grep($_ eq $so, @skipped) ) {
#                                        $stop = 1;
#                                    }
#                                }
#                            }
#                        }

                    }

                    if ($stop == 0 ) {
                        push(@order, $name);
                    }
                }

            } 
        }
    }
    if (@order == 0) {
        last;
    } else {
        push(@done, @order);
        print "Next pass:\n";
        foreach my $o (@order) {
            print $o . "\n";
        }
    }
    if ($dryrun) {
        exit 1
    }

    while (@order && ! $TERM) {
        # Keep max threads running
        for (my $needed = $MAX_THREADS - threads->list(); 
            $needed && ! $TERM; $needed--) {

            my $job = shift(@order);
            last if (! $job);


            my $worker = find_idle();
            my $thr = threads->create('build_package',$job, $worker);
            my $tid = $thr->tid();
            set_busy($worker, $tid);
        }
    }

    while ((threads->list() > 0)) {
        # waiting for threads to finish
        sleep(1);
    }

}

if ($packages_built) {
    createrepo ($arch, $dist);
}

if (@errors) {
    print "\n\n\nBuild failed for the following packages:\n";
    print "  $_\n" foreach @errors;
    exit 1
}

exit 0
